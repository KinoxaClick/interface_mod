(function(){
  'use strict';

  // ===============================================
  //  PlayUa v60 — Movies + Series for Lampa
  //  • ONE popup per season (all versions together)
  //  • Season list shows TMDB season posters again
  //  • ESC/Back reliably closes popup (global key capture + controller)
  //  • Each version (folder) has its own accent color
  //  • TV‑remote: explicit controller (up/down/enter/back) + focus
  //  • Show only video files >= 500 MB; 1‑based index for TorrServer
  //  • Language selection for dubbing
  // ===============================================

  // ---------- constants & helpers ----------
  const MIN_SEEDERS   = 3;
  const MOVIE_CATS    = '2000,2010,2020,2030,2040';
  const SERIES_CATS   = '5000,5030,5040,5050,5060,5070';
  const VIDEO_EXT     = /(\.(mkv|mp4|avi|ts|m2ts|mpg|mpeg|mov|wmv))$/i;
  const MIN_EP_BYTES  = 500 * 1024 * 1024; // 500 MB

  const PACK_COLORS = ['#60A5FA','#A78BFA','#34D399','#F59E0B','#F472B6','#4FC3F7','#F87171','#10B981','#EAB308','#C084FC'];

  const noty=(m,t)=>{ try{ Lampa.Noty.show(m,{time:t||2500}); }catch(_){} };
  const ensureScheme=u=>/^https?:\/\//i.test(u)?u:('http://'+u);
  const trimEnd=s=>s.replace(/\/+$/,'');
  const safeName=s=>(s||'video').replace(/[^\w\d]+/g,'.').replace(/\.+/g,'.').replace(/^\.+|\.+$/g,'') || 'video';
  const isSerial = m => !!m?.first_air_date && !m?.release_date;
  const looksLikeVideo = path => VIDEO_EXT.test(path||'');

  const tmdbLang = ()=>{ try{ return (Lampa.Storage.get('language')||'uk').toLowerCase(); }catch(_){ return 'uk'; } };
  function tmdbUrl(path, params){
    const qp = new URLSearchParams(params||{});
    try{ if (typeof Lampa.TMDB !== 'undefined' && typeof Lampa.TMDB.api === 'function') return Lampa.TMDB.api(path + (path.includes('?')?'&':'?') + qp.toString()); }catch(_){ }
    const KEY = '4ef0d7355d9ffb5151e987764708ce96';
    const base = 'http://api.themoviedb.org/3/';
    if (!qp.has('api_key')) qp.set('api_key', KEY);
    if (!qp.has('language')) qp.set('language', tmdbLang());
    return base + path + (path.includes('?')?'&':'?') + qp.toString();
  }

  // ---------- Language selection ----------
  const DUBBING_LANGUAGES = [
    { id: 'ukrainian', name: 'Українська', keywords: ['укр', 'українська', 'ukr', 'ukrainian', 'дубляж', 'dubbing'] },
    { id: 'russian', name: 'Русский', keywords: ['рус', 'russian', 'русс', 'лицензия', 'озвучка'] },
    { id: 'original', name: 'Оригінал', keywords: ['ориг', 'original', 'англ', 'eng', 'english'] }
  ];

  function getDubbingLanguage() {
    return Lampa.Storage.get('playua_dubbing') || 'ukrainian';
  }

  function setDubbingLanguage(lang) {
    Lampa.Storage.set('playua_dubbing', lang);
  }

  function filterByLanguage(items, preferredLang) {
    if (preferredLang === 'original') return items;
    
    const langConfig = DUBBING_LANGUAGES.find(l => l.id === preferredLang);
    if (!langConfig) return items;

    const langKeywords = langConfig.keywords;
    return items.filter(item => {
      const title = (item.title || '').toLowerCase();
      return langKeywords.some(keyword => title.includes(keyword));
    });
  }

  function createLanguageSelector(callback) {
    injectStyles();
    const dlg = openModal('ВИБІР ОЗВУЧЕННЯ');
    
    const $list = $(document.createDocumentFragment());
    const currentLang = getDubbingLanguage();

    DUBBING_LANGUAGES.forEach(lang => {
      const isSelected = lang.id === currentLang;
      const row = $(`
        <div class="playua-row selector ${isSelected ? 'focus' : ''}" tabindex="0">
          <div class="playua-title">${lang.name}</div>
          ${isSelected ? '<div class="playua-size">✓</div>' : ''}
        </div>
      `);
      
      row.on('hover:enter click keydown', (e) => {
        if (e.type === 'keydown' && e.key !== 'Enter' && e.keyCode !== 13) return;
        setDubbingLanguage(lang.id);
        dlg.close();
        if (callback) callback(lang.id);
      });
      
      $list.append(row);
    });

    dlg.setItems($list);
    return dlg;
  }

  // ---------- Jackett base ----------
  function jackettBase(){
    const raw=Lampa.Storage.field('jackett_url')||'';
    const key=Lampa.Storage.field('jackett_key')||'';
    if(!raw) throw new Error('Вкажи jackett_url у Налаштуваннях');
    let base=ensureScheme(raw).replace(/\/jackett(\/.*)?$/,'');
    return { base: trimEnd(base), key };
  }

  // ---------- TorrServer base + auth ----------
  function tsBase(){
    const raw=Lampa.Storage.field('torrserver_url')||'';
    if(!raw) throw new Error('Вкажи torrserver_url у Налаштуваннях');
    return trimEnd(ensureScheme(raw));
  }
  function tsAuthHeaders(){
    const token = Lampa.Storage.field('torrserver_token') || '';
    const user  = Lampa.Storage.field('torrserver_user')  || '';
    const pass  = Lampa.Storage.field('torrserver_pass')  || '';
    const headers = { 'Content-Type':'application/json' };
    if (token) headers['Authorization'] = 'Bearer ' + token;
    else if (user || pass){
      const btoaSafe = s=>{ try{ return btoa(s); }catch(_){ try{ return Buffer.from(s,'utf-8').toString('base64'); }catch(_2){ return ''; } } };
      headers['Authorization'] = 'Basic ' + btoaSafe(`${user}:${pass}`);
    }
    return headers;
  }
  function tsBaseForStream(){
    let base = tsBase();
    const user  = Lampa.Storage.field('torrserver_user')  || '';
    const pass  = Lampa.Storage.field('torrserver_pass')  || '';
    try{ const u = new URL(base); if (user || pass){ u.username=user; u.password=pass; base=u.toString().replace(/\/$/,''); } }catch(_){ }
    return base;
  }
  function tsStreamAuthQuery(){
    const token = Lampa.Storage.field('torrserver_token') || '';
    return token ? `&authorization=${encodeURIComponent('Bearer '+token)}` : '';
  }

  // ---------- TMDB payload ----------
  function getMoviePayload(data){
    const m=data?.movie; if(!m) throw new Error('Немає data.movie'); if(isSerial(m)) throw new Error('skip-serial');
    const title=(m.title||m.name||'').trim(); const orig=(m.original_title||m.original_name||title).trim(); const year=((m.release_date||'0000')+'').slice(0,4); if(!title) throw new Error('Не визначена назва фільму');
    const poster=m.poster_path?`http://image.tmdb.org/t/p/w300${m.poster_path}`:'';
    return { title, orig, year, poster, full:m };
  }
  function getShowPayload(data){
    const m=data?.movie; if(!m) throw new Error('Немає data.movie'); if(!isSerial(m)) throw new Error('skip-movie');
    const title=(m.name||m.title||'').trim(); const orig=(m.original_name||m.original_title||title).trim(); const tvId=m.id; const poster=m.poster_path?`http://image.tmdb.org/t/p/w300${m.poster_path}`:'';
    return { title, orig, tvId, poster, full:m };
  }

  // ---------- Jackett search ----------
  function parseTorznabXML(text){
    const xml=new DOMParser().parseFromString(text,'application/xml');
    let items=[...xml.querySelectorAll('item')].map(it=>{
      const xt=s=>(it.querySelector(s)?.textContent||'').trim();
      const xa=n=>(it.querySelector(`torznab\\:attr[name="${n}"]`)?.getAttribute('value')||'').trim();
      const enc = it.querySelector('enclosure')?.getAttribute('url') || '';
      const magnet = xa('magneturl') || xa('magnetUrl') || '';
      const link = magnet && magnet.startsWith('magnet:') ? magnet : (xt('link') || enc || '');
      const size = Number(xt('size') || xa('size') || 0);
      const seed = Number(xa('seeders') || xa('peers') || 0);
      const tracker = (xa('jackettindexer')||xa('indexer')||'').toLowerCase();
      const trackerId=(xa('jackettindexerid')||'').toLowerCase();
      return { title:xt('title'), link, magnet, dl:enc||'', size, seed, tracker, trackerId };
    }).filter(x=> x.link && x.size>0 && x.seed>=MIN_SEEDERS);
    const tol = items.filter(x=> x.tracker.includes('toloka') || x.trackerId.includes('toloka'));
    if (tol.length) items = tol;
    items.sort((a,b)=> b.size - a.size);
    return items;
  }
  function parseJackettJSON(json){
    const arr = Array.isArray(json)?json:(json?.Results||json?.results||json?.items||[]);
    let items=(arr||[]).map(x=>{
      const magnet=x.MagnetUri||x.MagnetUrl||x.magnet||'';
      const link=(magnet&&magnet.startsWith('magnet:'))?magnet:(x.Link||x.link||'');
      const size=Number(x.Size||x.size||0);
      const seed=Number(x.Seeders||x.seeders||x.Peers||x.peers||0);
      const tracker=(x.Tracker||x.tracker||'').toLowerCase();
      const trackerId=(x.TrackerId||x.trackerId||'').toLowerCase();
      return { title:x.Title||x.title||'', link, magnet, dl:'', size, seed, tracker, trackerId };
    }).filter(x=> x.link && x.size>0 && x.seed>=MIN_SEEDERS);
    const tol = items.filter(x=> x.tracker.includes('toloka') || x.trackerId.includes('toloka'));
    if (tol.length) items = tol;
    items.sort((a,b)=> b.size - a.size);
    return items;
  }
  async function jSearchTorznab(query, catsCSV){
    const { base, key } = jackettBase();
    const qp=new URLSearchParams({ t:'search', q:query });
    if (key) qp.set('apikey', key);
    for(const c of catsCSV.split(',').map(s=>s.trim()).filter(Boolean)) qp.append('cat',c);
    const url=`${base}/api/v2.0/indexers/all/results/torznab/?${qp}`;
    try{ const r=await fetch(url,{method:'GET',credentials:'omit',mode:'cors'}); if(!r.ok) return []; return parseTorznabXML(await r.text()); }catch(_){ return []; }
  }
  async function jSearchJSON(query, catsCSV, meta){
    const { base, key } = jackettBase();
    const qp=new URLSearchParams();
    if (key) qp.set('apikey', key);
    qp.set('Query',query);
    if(meta?.title) qp.set('title',meta.title);
    if(meta?.orig) qp.set('title_original',meta.orig);
    if(meta?.year) qp.set('year',meta.year);
    if(meta?.is_serial!=null) qp.set('is_serial', String(meta.is_serial?1:0));
    for(const c of catsCSV.split(',').map(s=>s.trim()).filter(Boolean)) qp.append('Category[]',c);
    const url=`${base}/api/v2.0/indexers/all/results?${qp}`;
    try{ const r=await fetch(url,{method:'GET',credentials:'omit',mode:'cors'}); if(!r.ok) return []; const json=await r.json(); return parseJackettJSON(json); }catch(_){ return []; }
  }

  // ---------- TorrServer ----------
  async function tsAdd(base, addLink, metaTitle, metaPoster, metaFull){
    const url = `${base}/torrents`;
    const body = { action:'add', link:addLink, title:`[LAMPA] ${metaTitle}`.trim(), poster: metaPoster||'', data: JSON.stringify({lampa:true,movie:metaFull}), save_to_db:false };
    const r=await fetch(url,{ method:'POST', headers: tsAuthHeaders(), body: JSON.stringify(body) });
    let j={}; try{ j=await r.json(); }catch(_){ }
    const hash = j.hash || j.id || j.link || j.data || j.result || '';
    return { hash, id:hash, raw:j };
  }
  function pickFileStats(j){
    if (!j) return [];
    if (Array.isArray(j)) return j;
    if (Array.isArray(j.file_stats)) return j.file_stats;
    if (Array.isArray(j.FileStats)) return j.FileStats;
    if (Array.isArray(j.files)) return j.files;
    if (Array.isArray(j.Files)) return j.Files;
    if (j.stats && Array.isArray(j.stats.file_stats)) return j.stats.file_stats;
    return [];
  }
  async function tsFiles(base, linkOrHash){
    const headers = tsAuthHeaders();
    try{
      const body = { action:'get' };
      if (/^(magnet:|https?:)/i.test(linkOrHash)) body.link = linkOrHash; else body.hash = linkOrHash;
      const r = await fetch(`${base}/torrents`, { method:'POST', headers, body: JSON.stringify(body) });
      if (r.ok){ const j = await r.json(); const fs = pickFileStats(j); if (fs.length) return { files:fs, raw:j }; }
    }catch(_){ }
    try{
      const r = await fetch(`${base}/stream/files?link=${encodeURIComponent(linkOrHash)}`, { method:'GET', headers });
      if (r.ok){ const j = await r.json(); const fs = pickFileStats(j); if (fs.length) return { files:fs, raw:j }; }
    }catch(_){ }
    return { files: [], raw: null };
  }

  function closeAllPlayUaModals(){
    try{ document.querySelectorAll('.playua-modal').forEach(el=>el.remove()); }catch(_){ }
    try{ Lampa.Modal.close(); }catch(_){ }
  }
  function tsPlayById(hash, file, title){
    closeAllPlayUaModals();
    const baseForStream = tsBaseForStream();
    const fname = safeName((file.path||'').split('/').pop()||title||'video') + '.mkv';
    let url = `${baseForStream}/stream/${encodeURIComponent(fname)}?link=${encodeURIComponent(hash)}&index=${file.id}&play=1`;
    const qAuth = tsStreamAuthQuery(); if (qAuth) url += qAuth;
    if (Lampa?.Player?.play) Lampa.Player.play({ url, title: title||fname, timeline:0 }); else location.href = url;
  }

  // ---------- Custom focusable modal ----------
  function injectStyles(){
    if (document.getElementById('playua-style')) return;
    const css = `
      .playua-modal{position:fixed;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,.72);z-index:9999;display:flex;align-items:center;justify-content:center}
      .playua-card{width:min(1450px,94vw);max-height:88vh;overflow:hidden;border-radius:16px;background:#111;border:1px solid rgba(255,255,255,.06);box-shadow:0 10px 40px rgba(0,0,0,.5)}
      .playua-head{padding:20px 28px;font-size:28px;font-weight:800;letter-spacing:.3px;background:rgba(255,255,255,.04)}
      .playua-body{padding:4px 8px 12px 8px;overflow:auto;max-height:calc(88vh - 72px)}
      .playua-row{display:flex;align-items:center;gap:18px;padding:16px;border-radius:12px}
      .playua-row.selector{cursor:pointer}
      .playua-row.selector.focus{outline:none;background:rgba(255,255,255,.06)}
      .playua-thumb{width:200px;height:112px;border-radius:10px;background:#222 center/cover no-repeat;flex:0 0 auto}
      .playua-title{font-size:30px;font-weight:800}
      .playua-sub{opacity:.8;margin-top:6px}
      .playua-size{margin-left:auto;opacity:.9;font-weight:700}
      .playua-loader{display:flex;align-items:center;gap:14px;padding:22px;font-size:22px}
      @media (max-width:860px){ .playua-thumb{width:160px;height:90px} .playua-title{font-size:24px} }
      /* Pack coloring */
      .playua-pack{--pack:#60A5FA; margin:6px 0 10px}
      .playua-pack-title{display:flex;align-items:center;gap:10px;padding:10px 14px;font-size:22px;font-weight:900;border-left:6px solid var(--pack);border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));color:#fff}
      .playua-folder{padding:3px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.08);}
      .playua-pack .playua-row{border-left:4px solid var(--pack)}
      .playua-pack .playua-row.selector.focus{box-shadow:inset 0 0 0 2px var(--pack)}
    `;
    const s=document.createElement('style'); s.id='playua-style'; s.textContent=css; document.head.appendChild(s);
  }
  function openModal(title){
    injectStyles();
    const root = document.createElement('div'); root.className='playua-modal'; root.tabIndex = 0;
    const card = document.createElement('div'); card.className='playua-card';
    const head = document.createElement('div'); head.className='playua-head'; head.textContent=title||'';
    const body = document.createElement('div'); body.className='playua-body';
    card.appendChild(head); card.appendChild(body); root.appendChild(card);
    document.body.appendChild(root);

    const $root=$(root), $body=$(body);

    const onKeyDown=(e)=>{
      const items=[...$body.find('.selector')];
      const idx = items.findIndex(n=>n.classList.contains('focus'));
      const clamp = (n)=> Math.max(0, Math.min(items.length-1, n));
      const backKeys=['Escape','Backspace','BrowserBack','GoBack'];
      if (['ArrowDown','ArrowUp','Home','End','PageDown','PageUp'].includes(e.key) || [38,40,33,34,35,36].includes(e.keyCode)) e.preventDefault();
      if ((e.key==='ArrowDown' || e.keyCode===40) && items.length){ items[idx]?.classList.remove('focus'); const ni=clamp((idx<0?0:idx)+1); items[ni].classList.add('focus'); items[ni].scrollIntoView({block:'nearest'}); }
      if ((e.key==='ArrowUp' || e.keyCode===38) && items.length){ items[idx]?.classList.remove('focus'); const ni=clamp((idx<0?0:idx)-1); items[ni].classList.add('focus'); items[ni].scrollIntoView({block:'nearest'}); }
      if ((e.key==='Enter' || e.keyCode===13 || e.keyCode===65376) && items.length && idx>=0){ $(items[idx]).trigger('hover:enter'); }
      if (backKeys.includes(e.key) || [8,27,10009,461].includes(e.keyCode)){ e.preventDefault(); hardClose(); }
    };

    const hardClose=()=>{ try{ $root.remove(); }catch(_){} document.removeEventListener('keydown', onKeyDown, true); try{ Lampa.Controller.toggle('content'); }catch(_){ } };

    function setItems(items){
      $body.empty().append(items);
      try{ Lampa.Controller.collectionSet($body); }catch(_){}
      focusFirst();
      try{ Lampa.Controller.toggle('playua_modal'); }catch(_){}
    }
    function setLoading(text){
      const row = $(`<div class="playua-loader"><div class="loader" style="width:26px;height:26px;border:3px solid rgba(255,255,255,.35);border-top-color:#fff;border-radius:50%;animation:plr .8s linear infinite"></div><div>${text||'Завантаження...'}</div></div>`);
      $body.empty().append(row);
      try{ Lampa.Controller.collectionSet($body); Lampa.Controller.toggle('playua_modal'); }catch(_){}
    }
    function focusFirst(){
      const first = $body.find('.selector').eq(0);
      if (first.length){ try{ Lampa.Controller.collectionSet($body); }catch(_){} first.addClass('focus'); first[0].scrollIntoView({block:'nearest'}); }
    }

    try{
      Lampa.Controller.add('playua_modal',{
        toggle: function(){ try{ Lampa.Controller.collectionSet($body); }catch(_){} },
        enter: function(){ const $el=$body.find('.selector.focus').eq(0); if($el.length) $el.trigger('hover:enter'); },
        back: function(){ hardClose(); }
      });
      setTimeout(()=>{ try{ Lampa.Controller.toggle('playua_modal'); }catch(_){ } }, 0);
    }catch(_){ }

    document.addEventListener('keydown', onKeyDown, true);
    setTimeout(()=>{ try{ root.focus(); }catch(_){ } }, 0);

    return { root:$root, body:$body, setItems, setLoading, close:hardClose };
  }

  // ---------- UI builders ----------
  function makePackHeader(text){ return $(`<div class="playua-pack-title"><span class="playua-folder">${text}</span></div>`); }
  function makeEpisodeRow(epNum, name, stillUrl, sizeText, tail){
    const row = $(`<div class="playua-row selector" tabindex="0">
      <div class="playua-thumb" style="background-image:url('${stillUrl||''}')"></div>
      <div>
        <div class="playua-title">S${String(epNum.season||1)}E${String(epNum.ep||0).padStart(2,'0')} — ${name||('Серія '+epNum.ep)}</div>
        <div class="playua-sub">${tail||''}</div>
      </div>
      <div class="playua-size">${sizeText||''}</div>
    </div>`);
    return row;
  }

  // ---------- Parsing helpers ----------
  function humanSize(bytes){
    if (!bytes && bytes!==0) return '';
    const u=['B','KB','MB','GB','TB']; let i=0; let n=Number(bytes);
    while(n>=1024 && i<u.length-1){ n/=1024; i++; }
    return (i>=2? n.toFixed(1):Math.round(n))+' '+u[i];
  }
  function extractSeasonsFromTitle(s){
    const str = String(s||'');
    const out = new Set();
    const rng = str.match(/s(?:eason)?\s*(\d{1,2})\s*[-–…]\s*(\d{1,2})/i);
    if (rng){ const a=Number(rng[1]), b=Number(rng[2]); for(let i=a;i<=b;i++) out.add(i); }
    const re = /(?:s(?:eason)?\s*(\d{1,2})|\bS(\d{1,2})\b|(?:[^\d]|^)(\d{1,2})\s*сез)/gi;
    for(const m of str.matchAll(re)){ const n = Number(m[1]||m[2]||m[3]); if(n) out.add(n); }
    if (!out.size) out.add(1);
    return [...out];
  }
  function parseEpisodeNum(path, seasonHint){
    const name = path.split('/').pop();
    let m = name.match(/s(\d{1,2})e(\d{1,3})/i); if (m) return { season:Number(m[1]), ep:Number(m[2]) };
    m = name.match(/(\d{1,2})x(\d{1,3})/i); if (m) return { season:Number(m[1]), ep:Number(m[2]) };
    m = name.match(/e[pP]?(\d{1,3})/i); if (m) return { season:seasonHint||0, ep:Number(m[1]) };
    m = name.match(/сер(ія|iя)?\s*(\d{1,3})/i); if (m) return { season:seasonHint||0, ep:Number(m[2]) };
    return { season:seasonHint||0, ep:0 };
  }
  function topFolderFromFiles(files){
    for(const f of files||[]){
      const p = String(f.path||'').replace(/^\/+/, '');
      if (p.includes('/')){ const seg = p.split('/')[0].trim(); if (seg) return seg; }
    }
    return '';
  }

  // ---------- SERIES flow ----------
  async function showSeasons(meta){
    const combos={ df:meta.orig, df_year:`${meta.orig}`, lg:meta.title, lg_df:`${meta.title} ${meta.orig}` };
    const pref=Lampa.Storage.field('parse_lang')||'df';
    const query=(combos[pref]||meta.orig).trim();

    noty('PlayUa: шукаю сезони — '+query);

    let items = await jSearchTorznab(query, SERIES_CATS);
    if(!items.length) items = await jSearchJSON(query, SERIES_CATS, { title:meta.title, orig:meta.orig, is_serial:1 });
    
    // Filter by selected language
    const preferredLang = getDubbingLanguage();
    items = filterByLanguage(items, preferredLang);
    
    if(!items.length) throw new Error('Jackett: немає результатів для обраної мови');

    const bySeason = new Map();
    for(const it of items){
      const seasons = extractSeasonsFromTitle(it.title);
      for(const s of seasons){ if(!bySeason.has(s)) bySeason.set(s, []); bySeason.get(s).push(it); }
    }

    const seasonNums = [...bySeason.keys()].sort((a,b)=>a-b);
    if(!seasonNums.length) throw new Error('Не знайдено релізів сезонів');

    // Prefetch TMDB season posters (fallback to series poster)
    const posters = {};
    await Promise.all(seasonNums.map(async sn=>{
      try{
        const r = await fetch(tmdbUrl(`tv/${meta.tvId}/season/${sn}`, { language: tmdbLang() }));
        if (r.ok){ const j = await r.json(); posters[sn] = j?.poster_path ? `http://image.tmdb.org/t/p/w300${j.poster_path}` : (meta.poster||''); }
        else posters[sn] = meta.poster||'';
      }catch(_){ posters[sn] = meta.poster||''; }
    }));

    const dlg = openModal('ОБЕРИ СЕЗОН');

    const $list = $(document.createDocumentFragment());
    for(const sn of seasonNums){
      const rels = bySeason.get(sn) || [];
      const bestSize = (rels.length? humanSize(rels.reduce((m,r)=> Math.max(m, Number(r.size||0)), 0)) : '');
      const thumb = posters[sn] ? `background-image:url('${posters[sn]}')` : 'background:#222';
      const row = $(`<div class="playua-row selector" tabindex="0"><div class="playua-thumb" style="${thumb}"></div><div><div class="playua-title">СЕЗОН №${sn}</div><div class="playua-sub">Варіантів: ${rels.length}</div></div><div class="playua-size">${bestSize||''}</div></div>`);
      row.on('hover:enter click keydown', (e)=>{ if (e.type==='keydown' && e.key!=='Enter' && e.keyCode!==13) return; fetchEpisodesAggregated(meta, sn, rels); });
      $list.append(row);
    }
    dlg.setItems($list);
  }

  async function fetchEpisodesAggregated(meta, sn, releases){
    const dlg = openModal(`СЕЗОН ${sn} — релізи та серії`);
    dlg.setLoading('Готую релізи…');

    // TMDB names & stills
    let tmdbSeason=null; const names={}, stills={};
    try{ const r=await fetch(tmdbUrl(`tv/${meta.tvId}/season/${sn}`,{language:tmdbLang()})); if(r.ok) tmdbSeason=await r.json(); }catch(_){ }
    if (tmdbSeason && Array.isArray(tmdbSeason.episodes)){
      tmdbSeason.episodes.forEach(e=>{ names[e.episode_number]=e.name||''; stills[e.episode_number]= e.still_path? `http://image.tmdb.org/t/p/w300${e.still_path}` : ''; });
    }

    const base = tsBase();
    const groups = new Map();
    const order  = [];

    for(const rel of releases){
      let link = rel.dl || rel.magnet || rel.link; let hash = link;
      try{ const added = await tsAdd(base, link, `${meta.title} (S${sn})`, '', meta.full); if (added.hash) hash = added.hash; }catch(_){ }

      try{
        const { files } = await tsFiles(base, hash);
        if(!files.length) continue;
        const vids = files.filter(x=> looksLikeVideo(x.path) && Number(x.length||0) >= MIN_EP_BYTES);
        if(!vids.length) continue;

        const folder = topFolderFromFiles(vids) || rel.title || 'Реліз';
        if (!groups.has(folder)){ groups.set(folder, []); order.push(folder); }

        const dest = groups.get(folder);
        for(const f of vids){
          const parsed = parseEpisodeNum(f.path, sn); const ep = parsed.ep||0; if(!ep) continue;
          const prev = dest.find(x=>x.ep===ep);
          const size = Number(f.length||0);
          if (!prev || size > prev.size){ dest.splice(prev? dest.indexOf(prev): dest.length, prev?1:0, { ep, file:f, hash, size, folder }); }
        }
      }catch(_){ }
    }

    const $list = $(document.createDocumentFragment());
    order.forEach((folder, idx)=>{
      const items = groups.get(folder)||[];
      if (!items.length) return;
      const color = PACK_COLORS[idx % PACK_COLORS.length];
      const wrap = $(`<div class="playua-pack" style="--pack:${color}"></div>`);
      wrap.append(makePackHeader(folder));
      items.sort((a,b)=> a.ep-b.ep);
      items.forEach(it=>{
        const row = makeEpisodeRow({season:sn, ep:it.ep}, names[it.ep]||`Серія ${it.ep}`, stills[it.ep]||'', humanSize(it.size), folder);
        row.on('hover:enter click keydown', (e)=>{ if(e.type==='keydown' && e.key!=='Enter' && e.keyCode!==13) return; tsPlayById(it.hash, it.file, `${meta.title} S${sn}E${String(it.ep).padStart(2,'0')}`); });
        wrap.append(row);
      });
      $list.append(wrap);
    });

    if (!$list.children().length) return dlg.setLoading('Не знайдено серій ≥500MB для цього сезону');
    dlg.setItems($list);
  }

  // ---------- MOVIE flow ----------
  async function runMovie(data){
    const meta = getMoviePayload(data);
    const combos={ df:meta.orig, df_year:`${meta.orig} ${meta.year}`, df_lg:`${meta.orig} ${meta.title}`, df_lg_year:`${meta.orig} ${meta.title} ${meta.year}`, lg:meta.title, lg_year:`${meta.title} ${meta.year}`, lg_df:`${meta.title} ${meta.orig}`, lg_df_year:`${meta.title} ${meta.orig} ${meta.year}` };
    const pref=Lampa.Storage.field('parse_lang')||'df_year';
    const query=(combos[pref]||`${meta.orig} ${meta.year}`).trim();

    noty('PlayUa: шукаю — '+query);

    let items = await jSearchTorznab(query, MOVIE_CATS);
    if(!items.length) items = await jSearchJSON(query, MOVIE_CATS, { title:meta.title, orig:meta.orig, year:meta.year, is_serial:0 });
    
    // Filter by selected language
    const preferredLang = getDubbingLanguage();
    items = filterByLanguage(items, preferredLang);
    
    if(!items.length) throw new Error('Jackett: немає результатів для обраної мови');

    const base = tsBase();
    const $list = $(document.createDocumentFragment());

    for(const it of items){
      let link = it.dl || it.magnet || it.link; let hash = link;
      try{ const added = await tsAdd(base, link, meta.title, meta.poster, meta.full); if (added.hash) hash = added.hash; }catch(_){ }

      try{
        const { files } = await tsFiles(base, hash);
        if(!files.length) continue;
        const vids = files.filter(x=> looksLikeVideo(x.path) && Number(x.length||0) >= MIN_EP_BYTES);
        if(!vids.length) continue;
        const best = vids.reduce((m,x)=> Number(x.length||0) > Number(m.length||0) ? x : m, vids[0]);
        const size = humanSize(best.length);
        const row = $(`<div class="playua-row selector" tabindex="0"><div class="playua-thumb" style="background-image:url('${meta.poster||''}')"></div><div><div class="playua-title">${it.title}</div><div class="playua-sub">${it.tracker||''}</div></div><div class="playua-size">${size}</div></div>`);
        row.on('hover:enter click keydown', (e)=>{ if(e.type==='keydown' && e.key!=='Enter' && e.keyCode!==13) return; tsPlayById(hash, best, meta.title); });
        $list.append(row);
      }catch(_){ }
    }

    if (!$list.children().length) throw new Error('Не знайдено файлів ≥500MB');
    const dlg = openModal('ОБЕРИ РЕЛІЗ');
    dlg.setItems($list);
  }

  // ---------- Plugin registration ----------
  function init(){
    if (typeof Lampa === 'undefined' || !Lampa.Storage) return setTimeout(init, 100);
    Lampa.Storage.set('playua_dubbing', getDubbingLanguage()); // Ensure default

    Lampa.Plugin.add('playua', {
      component: {
        template: `
          <div style="padding:20px;max-width:800px;margin:0 auto">
            <h1 style="font-size:32px;margin-bottom:20px">PlayUa — налаштування</h1>
            <div style="margin-bottom:20px">
              <h2 style="font-size:24px;margin-bottom:10px">Мова озвучення</h2>
              <div style="display:flex;gap:10px;flex-wrap:wrap">
                ${DUBBING_LANGUAGES.map(lang => `
                  <label style="display:flex;align-items:center;gap:5px;cursor:pointer">
                    <input type="radio" name="dubbing" value="${lang.id}" ${getDubbingLanguage() === lang.id ? 'checked' : ''} 
                           on-change="Lampa.Storage.set('playua_dubbing', this.value)">
                    ${lang.name}
                  </label>
                `).join('')}
              </div>
            </div>
          </div>
        `
      }
    });

    Lampa.Menu.add({
      title: 'PlayUa',
      component: 'playua'
    });

    Lampa.Player.add({
      name: 'playua',
      menu: {
        title: 'PlayUa',
        icon: 'menu_playua'
      },
      search: async function(data){
        try{
          if (isSerial(data.movie)){
            const meta = getShowPayload(data);
            await showSeasons(meta);
          }else{
            await runMovie(data);
          }
        }catch(e){
          if (e.message === 'skip-serial' || e.message === 'skip-movie') return;
          noty('PlayUa: '+e.message, 5000);
        }
      }
    });

    // Add language selector to context menu
    Lampa.Menu.addContext({
      title: 'Мова озвучення',
      click: () => {
        createLanguageSelector((lang) => {
          noty(`Мова озвучення встановлена: ${DUBBING_LANGUAGES.find(l => l.id === lang)?.name || lang}`, 3000);
        });
      }
    });
  }

  if (typeof Lampa !== 'undefined' && Lampa.Storage) init();
  else window.addEventListener('lampa', init);

})();
